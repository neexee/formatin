# Фоновые мысли студента ФИТ

### В университете не учат профессиям
Это не минус, это просто факт.
Причины две:
* Студенты должны сами выбрать свою профессию. Выпускники IT-факультетов вовсе не все поголовно разработчики. В IT множество разных профессий на любой вкус.
* Computer science и Software development не просто разные словосочетания, это в корне разные вещи. Первое – это наука, а второе – ремесло. Цель университета – дать представление о науке и научить думать. Цель профессии (в том числе учёного в области Computer science) же – сделать жизнь каких-нибудь людей проще.

В университете не рассказывают, как стать экспертом в какой-нибудь области. Потому что слово эксперт значит «извините, я разбираюсь только в одной вещи».

Выходит так, что совершенно не понятно, к чему нужно быть готовым после выпуска. Единственный вариант выпуститься и не разочароваться – это как можно раньше определиться с интересной областью ремесла. Потом нужно просто начать оттачивать в этой области навык в свободное от пар время. Классические варианты: разработка игровых движков, эмуляция миграции птиц, исследование теории категорий. Серьёзно, любая тема подойдёт, главное, чтобы в ней было в чём попрактиковаться. Если всё сделать правильно (вдумчиво и упорно), можно попасть в меньшиство людей, которым нравится их работа.

Нравиться она может по таким причинам:
* Часто нужно создавать или придумывать что-то новое. Это всегда интересно.
* Приятно делать вещи, приносящие пользу другим людям. Даже самые асоциальные люди хотят, чтобы другие пользовались результатами их работы.
* Разбираться в сложных программах, теориях или технологиях интересно. Интересно смотреть, как разные части программы взаимодействуют между собой. Каждая программа – это как часовой механизм с шестерёнками и пружинами, обычно шелестит и иногда тикает.
* Нужно постоянно учиться. Это не скучно, потому что новое никогда не повторяется.
* Забавно работать с вещами, которые существуют только в воображении. Похоже на постройку замков из воздуха.

К сожалению, есть и отрицательные моменты:
* Часто нужно сделать вещи идеально. Иногда от твоего кода зависит судьба целой компании. Часто люди могут смотреть на тебя криво после того, как чинили баги в твоём коде.
* Люди в профессии не всегда контролируют условия своей работы и даже цель своей работы. Часто другие люди задают цели, предоставляют ресурсы и снабжают информацией.
* Придумывать крутые идеи интересно, но починка мелких багов – это просто работа.
* Иногда приходится выкидывать наработки, которые ты делал неделями или даже месяцами.

В университете есть спецкурс, называется [Tech Talks](https://techtalks.nsu.ru/) можно попытаться найти там что-нибудь интересное. Есть вариант и получше, смотри последнюю тему в этом тексте.


### Технологии в словосочетании «информационные технологии» находятся на очень низком уровне
Не стоит думать, что в IT всё красивое и удобное. 50 лет энтузиасты по всему миру совместно пишут код. Ещё дольше пишут код наёмные программисты. Казалось бы, за это время можно было бы сделать простые и эффективные решения большинства проблем современных промышленных программистов.
В реальности львиная доля существующих библиотек, фреймворков, языков программирования и вспомогательных программ вокруг них находится в настолько отвратительном состоянии, что часто проще написать свои. Смотри «[No silver bullet](https://en.wikipedia.org/wiki/No_Silver_Bullet)».

Говорят, к 2040 году наступит [технологическая сингулярность](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D1%81%D0%B8%D0%BD%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D0%BE%D1%81%D1%82%D1%8C) и все проблемы людей решат роботы. По факту мы в 2038 году будем решать проблему того, что unix time (число секунд, прошедших с 1 января 1970 года) [перестанет влезать](https://en.wikipedia.org/wiki/Year_2038_problem) в int32 (четырёхбайтовый int).

Работы на всех хватит.


### Эффективно бороться со скукой нужно учиться самостоятельно
У скуки два источника:
1. Для решения проблемы не нужно использовать своё воображение.
2. Проблемы не бросают тебе вызов.

В университете скучными могут быть лекции или практические занятия.

Любой курс лежит в многомерном пространстве с осями: полезность, интересность, сложность, важность и продолжительность. Корень проблемы в том, что эти оси не независимые. Например, если снижать сложность курса, падает его полезность. Часто ради важных вещей жертвуют интересностью. Часто в курсе интересные только сложные вещи, но сложные вещи не рассказывают, нет времени.

Для лекций очень нужно постараться узнать у преподавателей конечную цель курса. Тогда очередная лекция будет ложиться куском мозаики, а воображение будет крутить этот паззл. Не скучно. Для практических занятий это просто полезно. К сожалению, часто выходит так, что суть курса становится понятной только после того, как вышел с экзамена (плюс-минус пара дней). Иногда становится понятно только через несколько лет. На мой взгляд, частое отсутствие конечных целей курсов – это одна из самых неприятных особенностей образования. [Илон Маск считает так же](https://youtu.be/UVHPHNegJNc?t=43).

Если конечная цель непонятная, можно придумать себе задание, связанное с тем, что *вы* ожидали от курса. Например, для курса информационнной безопасности в деталях разобраться, как работает HTTPS.
Или для курса операционных систем прочитать [Linux Kernel Development](https://github.com/yuanhui-yang/Linux-Kernel-Development/blob/master/Linux%20Kernel%20Development%20-%203rd%20Edition.pdf). Не важно, если понять удастся только малую часть. Важно погрузиться в проблемы области, свыкнуться с терминологией и понять основные идеи.

Для практических заданий дополнительно нужно:
1. Придумывать киллерфичи. Например, написать не обычного сапёра, а сапёра с красивой и сложной анимацией при взрыве бомбы.
2. Делать задания _по-другому_. Самое простое – это написать код на необычном для университета языке, например, Go, Haskell, Scala или Python.

Студенты каждый год тратят тысячи человекочасов на решение одних и тех же заданий. Результаты идут на выброс, хотя почти всегда можно сделать что-нибудь полезное. [Пример и намёк](https://github.com/search?utf8=%E2%9C%93&q=%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4+%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8&type=) для переводных заданий по английскому языку.
Желание сделать что-нибудь интересное ради забавы может зайти _очень_ далеко, смотри Just for Fun: The Story of an Accidental Revolutionary ([оригинал](https://linuxbbq.org/PDF/Linus%20Torvalds,%20David%20Diamond%20-%20Just%20for%20fun%20The%20Story%20of%20an%20Accidental%20Revolutionary.pdf), [перевод](http://lmsh.edu.ru/files/Devid_Daymond_Linus_Torvalds_Just_for_fun_Ra.pdf)). Это биография Линуса Торвальдса, наверное, самого знаменитого современного программиста.


### Нужно научиться эффективно работать с компьютером, особенно с программами про ввод текста
С текстом приходится работать много. Львиная доля времени, конечно, уходит на чтение, но когда нужно писать, _необходимо_ сделать так, чтобы ничто не отвлекало. Особенно существование клавиатуры.
Для того, чтобы сделать работу за компьютером приятной, нужно:
* Осилить слепую печать в двух раскладках. Тренажёр, наверное, любой. Я пользовался klavaro, сразу начиная с заданий на скорость (потому что сидеть и нажимать `фжфжфжфжфжф` уж слишком уныло).
* Сделать себе удобные хоткеи.
  * Повесить переключение раскладки на Caps Lock. Самый простой вариант для Windows – установить себе [Punto Switcher](https://yandex.ru/soft/punto/) (от него нужна только фича про назначение хоткея на переключение раскладки). Думаю, пользователи GNU/Linux и сами с усами, давно про это знают.
  * Осилить хоткеи манипуляции окнами. Для пользователей GNU/Linux есть [вариант](https://ru.wikipedia.org/wiki/%D0%A4%D1%80%D0%B5%D0%B9%D0%BC%D0%BE%D0%B2%D1%8B%D0%B9_%D0%BE%D0%BA%D0%BE%D0%BD%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B5%D0%BD%D0%B5%D0%B4%D0%B6%D0%B5%D1%80), раз и навсегда избавляющий от необходимости перетаскивать окна мышью. Особенно это актуально для нескольких мониторов (у классическихх программистов 2+ монитора). Рекомендую i3, [тут](https://www.youtube.com/watch?v=Wx0eNaGzAZU) видео с ним.

Опционально можно попробовать альтернативные раскладки (_не_ QWERTY) клавиатуры. Для английского языка очень хороша [colemak](https://colemak.com/), пользоваться ей одно удовольствие. К сожалению, относительно популярной хорошей русской раскладки нет (хотя Диктор и Зубачёва были многообещающими). Зато есть [типографская раскладка](https://ilyabirman.ru/projects/typography-layout/).


### Очевидно, что нужно читать что-то помимо конспектов. Непонятно только, что именно читать
Посмотрите, [о чём обычно думают](https://www.joelonsoftware.com/2006/10/25/the-guerrilla-guide-to-interviewing-version-30/) собеседующие во время собеседования.
Если вкратце, человек – очень хороший кандидат, если он умный **и** доводит дела до конца.
Оба качества можно заработать с помощью книг. Для программистов список [примерно такой](https://stackoverflow.com/a/1713). Во многие из этих книг вложены годы труда и десятки лет опыта. Читать их лучше начинать _сейчас_, потому что _потом_ будет всё меньше и меньше свободного времени, а прочитать их _нужно_.

Несколько комментариев к этому списку (по ссылкам переводы с первой страницы выдачи гугла, хотя все оригиналы несложные):
* [Structure and Interpretation of Computer Programs](http://newstar.rinet.ru/~goga/sicp/sicp.pdf) – скорее всего, лучшая книга по программированию  **вообще**. В ней очень много кода, она сложная. Зато если всё понять, просветление обеспечено.
* [Introduction to Algorithms](https://e-maxx.ru/bookz/files/cormen.pdf) и [The Art of Computer Programming](https://ru.wikipedia.org/wiki/%D0%98%D1%81%D0%BA%D1%83%D1%81%D1%81%D1%82%D0%B2%D0%BE_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F) суровые книги об алгоритмических основах программирования.
* У университета мало рычагов для мотивации студентов, поэтому студенты должны мотивировать себя сами.
  При недостатке мотивации предлагаю читать эти две книги:
  * `Pragmatic Thinking and Learning: Refactor Your Wetware`
  * [The Passionate Programmer: Creating a Remarkable Career in Software Development](https://github.com/etartakovsky/passionate-programmer-translation)

  В них написано, как эффективно использовать своё время и силы.

* [Code Complete](https://www.bsuir.by/m/12_100229_1_98218.pdf) и `Clean Code: A Handbook of Agile Software Craftsmanship` про то, как сделать так, чтобы за код было не стыдно. Про то, как должен выглядеть зрелый стиль кода профессионала.

* `The Clean Coder: A Code of Conduct for Professional Programmers` – это книга про то, что значит быть _профессионалом_. Как себя профессионалы ведут, какие слова говорят, о чём думают. [The Pragmatic Programmer: From Journeyman to Master](https://www.ozon.ru/context/detail/id/3353337/) из той же категории. Она очень интересная и полезная, даже несмотря на то, что местами встречаются примеры мёртвых и неактуальных технологий.
* `Effective C++` – пример (просто пример, читать её не обязательно) того, какой должна быть книга о языке программирования. В ней подразумевается, что читатель программирует, поэтому рассказ идёт сразу о сути языка, а не о его синтаксисе. Породила целый жанр книг `Effective X`.

* Про паттерны в ближайшие несколько лет рекомендую особо не заморачиваться, хоть `Patterns of Enterprise Application Architecture` и [Design Patterns](http://modis.ispras.ru/Lizorkin/private/patterns.pdf) и общепризнанная классика. На старших курсах есть предмет про них.

* Остальное нужно выбирать на свой вкус. Есть только одно предостережение: лучше избегать закрытых технологий. Бывает, что некоторые компании создают между вами и решениями ваших проблем искусственные барьеры, а потом пытаются продать вам услуги по поддержке. Иногда эти компании пытаются защитить свою интеллектуальную собственность и [выдвигают бредовые требования в суде](https://geektimes.ru/post/143447/).

Смотри также [советы](https://www.joelonsoftware.com/2005/01/02/advice-for-computer-science-college-students/) Джоэла Спольски ([перевод сомнительного качества](http://russian.joelonsoftware.com/Articles/AdviceforComputerScienceC.html)).
